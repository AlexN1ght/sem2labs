-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-
cmp — Unix-утилита, сравнивает два файла и, если они различаются,
сообщает о первом байте и строке, где было обнаружено различие.
-
igor@igor-vm:~$ cmp --help
Использование: cmp [КЛЮЧ]? ФАЙЛ1 [ФАЙЛ2 [Н1 [Н2]]]
Побайтово сравнивает два файла.

Необязательные Н1 и Н2 ? это число байт, которые следует пропустить
в каждом файле (по умолчанию 0).

Аргументы, обязательные для длинных параметров, обязательны и для коротких.
  -b, --print-bytes       выводить различающиеся байты
  -i, --ignore-initial=Н  пропустить первые Н байт ввода
  -i, --ignore-initial=Н1:Н2
                        пропустить первые Н1 байт файла ФАЙЛ1
                        и первые Н2 байт файла ФАЙЛ2
  -l,  --verbose          выводить номера и значения всех различающихся байт
  -n, --bytes=Н      сравнивать не более Н байт
  -s, --quiet, --silent   не показывать обычные сообщения
      --help              показать эту справку и выйти
  -v, --version           показать информацию о версии и выйти

К значениям Н можно приписывать один из следующих множительных суффиксов:
kB 1000, K 1024, MB 1,000,000, M 1,048,576,
GB 1,000,000,000, G 1,073,741,824, и так далее для T, P, E, Z, Y.
                                                                                                                                                                                                                                 
Если ФАЙЛ не задан или задан как ?-?, то читается стандартный ввод.                                                                                                                                                              
Выходной статус равен 0, если входные файлы идентичны, 1 ? если                                                                                                                                                                  
различаются, и 2 в случае неполадок.                                                                                                                                                                                             
                                                                                                                                                                                                                                 
Об ошибках сообщайте по адресу <bug-diffutils@gnu.org>                                                                                                                                                                           
Домашняя страница GNU diffutils: <http://www.gnu.org/software/diffutils/>                                                                                                                                                        
Справка по работе с программами GNU: <http://www.gnu.org/gethelp/>   
gor@igor-vm:/bin$ cmp -b bash ip
bash ip различаются: байт 17, строка 1 равен  12 ^J   3 ^C
igor@igor-vm:/bin$ 
igor@igor-vm:/bin$ cmp -l bash ip
...(Я сократил для экономии места)
44315 376   0
444316 377   0
444317 101   0
444318 211   0
444319 307   0
444320 101   0
444321 215   5
444322 106   0
444323   1   0
444324 101   0
444325  71   0
444326 307   0
...

-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-
comm — утилита unix, читает файл1 и файл2, 
которые должны быть предварительно лексически отсортированы,
и генерирует вывод, состоящий из трёх колонок текста: строки, найденные только в файле файл1;
строки, найденные только в файле файл2; и строки, общие для обоих файлов. 
Имя файла «-» означает стандартный ввод. Перед каждой колонкой будет напечатано столько 
символов табуляции, сколько печатается колонок с меньшими номерами. 
Например, если вывод второй колонки подавляется, то перед строками, 
печатаемыми в первой колонке, символов табуляции не будет совсем, 
а перед строками в третьей колонке будет напечатан один символ табуляции.
-
Утилита comm предполагает, что файлы были предварительно лексически отсортированы;
все символы участвуют в сравнении строк.

igor@igor-vm:/bin$ comm --help
Использование: comm [КЛЮЧ]… ФАЙЛ1 ФАЙЛ2
Сравнивает сортированные файлы ФАЙЛ1 и ФАЙЛ2 построчно.

Если ФАЙЛ1 или ФАЙЛ2 (но не оба) задан как -, читается стандартный ввод.

При запуске без ключей выдает результат в три столбца. Первый столбец
содержит строки, уникальные для ФАЙЛА1, второй — уникальные для
ФАЙЛА2, а третий — общие для обоих файлов строки.

  -1                      не показывать столбец 1 (строки, уникальные
                          для ФАЙЛА1)
  -2                      не показывать столбец 2 (строки, уникальные
                          для ФАЙЛА2)
  -3                      не показывать столбец 3 (строки, встреченные
                          в обоих файлах)

  --check-order           проверить правильность сортировки ввода, даже
                          если все входные строки имеют пару
  --nocheck-order         не проверять правильность сортировки ввода
  --output-delimiter=РАЗ  отделять столбцы с помощью РАЗделителя
  --total                 показывать сводку
  -z, --zero-terminated        разделитель строк NUL, а не символ
                               новой строки
      --help     показать эту справку и выйти
      --version  показать информацию о версии и выйти

Заметим, что при сравнении действуют правила, задаваемые «LC_COLLATE».

Примеры:
  comm -12 файл1 файл2  вывести только строки, имеющиеся в файле1 и файле2.
  comm -3  файл1 файл2  вывести строки файла1, которых нет в файле2 и наоборот.
  
  
-
Первый файл: f.txt 
агути
заяц
кошка
собака
ящерица

Второй файл: s.txt 
агути
заяц
кошка
собака
ящерица
 
@igor-vm:~$ comm f.txt s.txt
 
      агути
 
               заяц
 
               кошка
 
       мышь
 
               собака
 
               ящерица
			   
-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-
Команда wc подсчитает количество строк, слов, байт, или символов в текстовом файле.

igor@igor-vm:~$ wc --help
Использование: wc [КЛЮЧ]… [ФАЙЛ]…
       или:    wc [КЛЮЧ]… --files0-from=Ф
Печатает число символов новой строки, слов и байт для каждого ФАЙЛА и
итоговую строку, если было задано несколько ФАЙЛОВ. Словом считается
последовательность символов ненулевой длины, отделённая пробельным символом.

Если ФАЙЛ не задан или задан как -, читает стандартный ввод.

Для выбора выводимых счётчиков используются следующие параметры
(счётчики всегда выводятся в таком порядке: символы новой строки,
слова, символы, байты, максимальная длина строки):
  -c, --bytes            напечатать количество байт
  -m, --chars            напечатать количество символов
  -l, --lines            напечатать количество новых строк
      --files0-from=Ф    читать ввод из файлов, имена которых
                         (завершённые нулем) перечислены в файле Ф;
                         Если Ф равно -, то читать имена файлов из
                         стандартного ввода
  -L, --max-line-length  напечатать максимальной число строк по ширине экрана
  -w, --words            напечатать количество слов
      --help     показать эту справку и выйти
      --version  показать информацию о версии и выйти

 igor@igor-vm:~$ wc /boot/burg2/menu /boot/grub/menu.lst
  55  167  817 
  34  102  776 /boot/grub/menu.lst
  89  269  1593 итого
  
-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-
# dd - Создание ISO образов с диска CD-ROM;
igor@igor-vm:~$ dd if=/opt/swappp/dev/hdc of=/tmp/mybackup.iso bs=2048 conv=notrunc

dd --help
Использование: dd [ОПЕРАНД]…
       или:    dd ПАРАМЕТР
Копирует файл, преобразует и форматирует в зависимости от операндов.

  bs=ЧИСЛО        читать и писать до ЧИСЛА байт за раз
  cbs=ЧИСЛО       преобразовывать заданное ЧИСЛО байт за раз
  conv=СПИСОК     преобразовывать файл в соответствии со СПИСКОМ символов,
                  элементы перечисляются через запятую
  count=ЧИСЛО     копировать только заданное ЧИСЛО входных блоков
  ibs=ЧИСЛО       считывать до ЧИСЛА байт за раз (по умолчанию 512)
  if=ФАЙЛ         читать ФАЙЛ, а не стандартный ввод
  iflag=ФЛАГИ     читать в соответствии со списком символов,
                  элементы перечисляются через запятую
  obs=ЧИСЛО       записывать заданное ЧИСЛО байт за раз (по умолчанию 512)
  of=ФАЙЛ         записывать в ФАЙЛ, а не на стандартный вывод
  oflag=ФЛАГИ     записывать в соответствии со списком символов,
                  элементы перечисляются через запятую
  seek=ЧИСЛО      пропустить перед началом вывода заданное ЧИСЛО блоков
                  размером obs
  skip=ЧИСЛО      пропустить перед началом ввода заданное ЧИСЛО блоков
                  размером ibs
  status=ИНФО     заданную ИНФОрмацию не выводить в stderr;
                  «noxfer» — не выводить статистику передачи
                  «none»  — не выводить ничего
                  «progress» — показывать индикатор передачи

После ЧИСЛА блоков и байт может стоять один из умножающий суффиксов:
c =1, w =2, b =512, kB =1000, K =1024, MB =1000*1000, M =1024*1024, xM =M,
GB =1000*1000*1000, G =1024*1024*1024 и так далее для T, P, E, Z, Y.

Каждый символ СПИСКА может быть:

  ascii     из EBCDIC в ASCII
  ebcdic    из ASCII в EBCDIC
  ibm       из ASCII в альтернативную EBCDIC
  block     дополнять записи, заканчивающиеся переводом строки, пробелами до
            размера cbs
  unblock   заменять завершающие пробелы в записях размера cbs на
            перевод строки
  lcase     изменять регистр с верхнего на нижний
  ucase     изменять регистр с нижнего на верхний
  sparse    попытаться переместиться, а не записывать в вывод NUL
            входных блоков
  swab      переставить местами каждую пару входных байт
  sync      дополнять каждый входной блок NUL-ми до размера ibs; при
            использовании с block или unblock, дополнять пробелам, а не NUL
  excl      завершать с ошибкой, если выходной файл уже существует
  nocreat   не создавать выходной файл
  notrunc   не обрезать выходной файл
  noerror   продолжать после ошибок чтения
  fdatasync физически записать выходной файл перед завершением
  fsync     аналогично, но записать также метаданные

Символ ФЛАГ может быть таким:

  append    режим добавления (имеет смысл для вывода; рекомендуется conv=notrunc)
  direct    использовать прямой ввод/вывод для данных
  directory выдавать ошибку, если это не каталог
  dsync     использовать синхронизированный ввод/вывод для данных
  sync      то же, но так же и для метаданных
  fullblock накапливать полные блоки входных данных (только iflag)
  nonblock  использовать неблокирующий ввод/вывод
  noatime   не обновлять время последнего доступа
  nocache   запрос на сброс кэша. Смотрите также oflag=sync
  noctty    не назначать управляющий терминал из файла
  nofollow  не следовать по символьным ссылкам
  count_bytes  считать «count=N» как счётчик байт (только с iflag)
  skip_bytes   считать «skip=N» как счётчик байт (только с iflag)
  seek_bytes   считать «seek=N» как счётчик байт (только с oflag)

Если послать работающему процессу «dd» сигнал USR1, он напечатает на
стандартный поток ошибок статистику ввода/вывода и продолжит
копирование.
 
 
-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-
mktemp - создает уникальное временное имя файла
-
igor@igor-vm:~$ mktemp --help
Использование: mktemp [КЛЮЧ]… [ШАБЛОН]
Создаёт временный файл или каталог безопасным способом, и печатает его имя.
ШАБЛОН должен содержать в последнем компоненте, по крайней мере, 3 «X» подряд.
Если ШАБЛОН не указан, то используется tmp.XXXXXXXXXX и
подразумевается --tmpdir.
Файлы создаются с правами u+rw, а каталоги с правами u+rwx,
минус ограничения umask.

  -d, --directory    создать каталог, а не файл
  -u, --dry-run      ничего не создавать; просто напечатать имя (небезопасно)
  -q, --quiet        не выдавать диагностику об ошибках создания файл/каталога
      --suffix=СУФФ  добавлять СУФФикс к ШАБЛОНУ; СУФФикс не должен содержать
                     символов косой черты. Подразумевается, что этот ключ
                     установлен, если ШАБЛОН не заканчивается X
  -p КАТ, --tmpdir[=КАТ]
                     рассматривать ШАБЛОН относительно КАТ; если КАТ не
                     указан, использовать $TMPDIR если задана, иначе /tmp.
                     С этим ключом ШАБЛОН не должен быть абсолютным именем;
                     в отличие от -t, ШАБЛОН может содержать косые черты, но
                     даже в этом случае, mktemp создаст только
                     последний компонент
  -t                 рассматривать ШАБЛОН как одно имя файла,
                     относительно каталога: $TMPDIR, если задан; иначе
                     каталог задаётся через -p; иначе /tmp (устарел)
      --help     показать эту справку и выйти
      --version  показать информацию о версии и выйти
-
igor@igor-vm:~$ TEMP=$(mktemp /tmp/temporary-file.XXXXXXXX)
igor@igor-vm:~$ echo something > ${TEMP}
igor@igor-vm:~$ echo $TEMP
/tmp/temporary-file.yP9xVHeN

-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-
Kоманда Grep, (расшифровывается как global regular expression print) одна из самых популярных команд 
в терминале Linux, которая входит в состав проекта GNU. 
В первую очередь потому, что это очень мощная утилита, 
kоторая дает возможность пользователям сортировать и фильтровать текст на основе сложных правил.

igor@igor-vm:~$ grep --help
Использование: grep [ПАРАМЕТР]… ШАБЛОН [ФАЙЛ]…
Поиск ШАБЛОНА в каждом ФАЙЛЕ.
Пример: grep -i 'hello world' menu.h main.c

Шаблон выбора и его интерпретация:
  -E, --extended-regexp  ШАБЛОН — расширенное регулярное выражение
  -F, --fixed-regexp     ШАБЛОН — строки, разделённые символом новой строки
  -G, --basic-regexp     ШАБЛОН — простое регулярное выражение (по умолчанию)
  -P, --perl-regexp      ШАБЛОН — регулярное выражения языка Perl
  -e, --regexp=ШАБЛОН    использовать ШАБЛОН для поиска
  -f, --file=ФАЙЛ        брать ШАБЛОН из ФАЙЛа
  -i, --ignore-case      игнорировать различие регистра
  -w, --word-regexp      ШАБЛОН должен подходить ко всем словам
  -x, --line-regexp      ШАБЛОН должен подходить ко всей строке
  -z, --null-data        строки разделяются байтом с нулевым значением, а не
                         символом конца строки

Разное:
  -s, --no-messages         не показывать сообщения об ошибках
  -v, --invert-match        выбирать не подходящие строки
  -V, --version             показать информацию о версии и закончить работу
      --help                показать эту справку и закончить работу

Управление выводом:
  -m, --max-count=ЧИСЛО     остановиться после указанного
                            ЧИСЛА выбранных строк
  -b, --byte-offset         печатать вместе с выходными строками смещение в
                            байтах
  -n, --line-number         печатать номер строки вместе с выходными строками
      --line-buffered       сбрасывать буфер после каждой строки
  -H, --with-filename       печатать имя файла для каждой выводимой строки
  -h, --no-filename         не начинать вывод с имени файла
      --label=МЕТКА         использовать МЕТКУ в качестве имени файла для
                            стандартного ввода
  -o, --only-matching       показывать только часть строки, совпадающей с ШАБЛОНОМ
  -q, --quiet, --silent     подавлять весь обычный вывод
      --binary-files=ТИП    считать, что двоичный файл имеет ТИП:
                            «binary», «text» или «without-match».
  -a, --text                то же что и --binary-files=text
  -I                        то же, что и --binary-files=without-match
  -d, --directories=ДЕЙСТВ  как обрабатывать каталоги
                            ДЕЙСТВИЕ может быть «read» (читать),
                            «recurse» (рекурсивно) или «skip» (пропускать).
  -D, --devices=ДЕЙСТВ      как обрабатывать устройства, FIFO и сокеты
                            ДЕЙСТВИЕ может быть «read» или «skip»
  -r, --recursive           то же, что и --directories=recurse
  -R, --dereference-recursive                             тоже, но с переходом по всем символьным ссылкам
      --include=Ф_ШАБЛОН    обработать только файлы, подпадающие под Ф_ШАБЛОН
      --exclude=Ф_ШАБЛОН    пропустить файлы и каталоги,
                            подпадающие под Ф_ШАБЛОН
      --exclude-from=ФАЙЛ   пропустить файлы, подпадающие под шаблон
                            файлов из ФАЙЛА
      --exclude-dir=ШАБЛОН  каталоги, подпадающие под ШАБЛОН,
                            будут пропущены
  -L, --files-without-match печатать только имена ФАЙЛОВ без выбранных строк
  -l, --files-with-matches  печатать только имена ФАЙЛОВ с выбранными строками
  -c, --count               печатать только количество выбранных
                            строк на ФАЙЛ
  -T, --initial-tab         выравнивать табуляцией (если нужно)
  -Z, --null                печатать байт 0 после имени ФАЙЛА

Управление контекстом:
  -B, --before-context=ЧИС  печатать ЧИСЛО строк предшествующего контекста
  -A, --after-context=ЧИС   печатать ЧИСЛО строк последующего контекста
  -C, --context[=ЧИС]       печатать ЧИСЛО строк контекста
  -ЧИСЛО                    то же, что и --context=ЧИСЛО
      --color[=КОГДА],
      --colour[=КОГДА]      использовать маркеры для различия совпадающих
                            строк; КОГДА может быть «always» (всегда),
                            «never» (никогда) или «auto» (автоматически)
  -U, --binary              не удалять символы CR в конце строки
                            (MSDOS/Windows)


igor@igor-vm:~$ grep -w '\<good' * $ grep -w 'yesterday\>' *

Первая часть ищет строки которые начинаются со слова ‘good’ 
а вторая строки которые заканчиваются на слово ‘yesterday’.

-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-
join — команда UNIX-подобных операционных систем, 
объединяющая строки двух упорядоченных текстовых файлов на основе наличия общего поля. 
По своему функционалу схоже с оператором Join, используемого в языке SQL, 
но оперирует с текстовыми файлами. 
Данная утилита написана Майком Хертелем (англ. Mike Haertel).

igor@igor-vm:~$ join --help
Использование: join [КЛЮЧ]… ФАЙЛ1 ФАЙЛ2
Для каждой пары входных строк с одинаковыми общими полями выводит строку на
стандартный вывод. По умолчанию общее поле считается первым, поля разделяются
пробелами.

Если ФАЙЛ1 или ФАЙЛ2 (но не оба) задан как -, читается стандартный ввод.

  -a НОМЕР           также печатать не имеющие пары строки из файла НОМЕР,
                     где НОМЕР может быть 1 или 2, которые соответствуют
                     ФАЙЛУ1 и ФАЙЛУ2
  -e СТРОКА          замещать при выводе пустые строки указанной СТРОКОЙ
  -i, --ignore-case  игнорировать регистр букв при сравнении полей
  -j ПОЛЕ            эквивалентно «-1 ПОЛЕ -2 ПОЛЕ»
  -o ФОРМАТ          выводить в соответствии с ФОРМАТОМ
  -t СИМ             использовать СИМВОЛ как разделитель полей ввода и вывода
  -v НОМЕР           как -а НОМЕР, но не печатать объединяемые выходные
                     строки
  -1 ПОЛЕ            считать общим заданное ПОЛЕ файла 1
  -2 ПОЛЕ            считать общим заданное ПОЛЕ файла 2
  --check-order      проверить правильность сортировки ввода, даже
                     если все входные строки имеют пару
  --nocheck-order    не проверять правильность сортировки ввода
  --header           считать первую строку каждого файла названиями полей,
                     выводить их без выполнения поиска пары
  -z, --zero-terminated        разделитель строк NUL, а не символ
                               новой строки
      --help     показать эту справку и выйти
      --version  показать информацию о версии и выйти
	  
igor@igor-vm:~$ join  -j1 4 -j2 3 -o 1.1 2.1 1.6 -t: /opt/etc/passwd.ls \ /opt/etc/group.ls
Следующая командная строка выполняет соединение файла паролей и файла групп,
сравнивая числовой идентификатор группы, и выдает входное имя, имя группы и основной каталог.
Предполагается, что оба файла отсортированы в порядке возрастания идентификаторов групп.

-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-
Команда sort сортирует содержимое файла в алфавитном или нумерологическом порядке. 
Если задать несколько файлов, то команда sort соединит их и, рассортировав, выдаст единым выводом. 
По умолчанию, объектом сортировки будут строки, однако опции позволяют выбирать объект сортировки: 
колонки, столбцы и прочие элементы форматирования файла. 
Разделителем между ними служат пробелы, однако соответствующие опции позволяют задать иные разделители.

Команда sort весьма древняя, она может служить образцом программирования утилит в ранних 70-х годах
прошлого века. У команды множество опций, и их разнообразные сочетания, а также способы задания
разделителей, хорошо развивают память и воображение.

igor@igor-vm:~$ sort --help
Использование: sort [КЛЮЧ]… [ФАЙЛ]…
       или:    sort [КЛЮЧ]… --files0-from=Ф
Печатает сортированное слияние всех ФАЙЛ(ов) на стандартный вывод.

Если ФАЙЛ не задан или задан как -, читает стандартный ввод.

Аргументы, обязательные для длинных ключей, обязательны и для коротких.
Ключи, задающие порядок:

  -b, --ignore-leading-blanks игнорировать начальные пропуски
  -d, --dictionary-order      рассматривать только пропуски, буквы и цифры
  -f, --ignore-case           игнорировать регистр букв
  -g, --general-numeric-sort  сравнивать в соответствии с общим числовым
                              значением
  -i, --ignore-nonprinting    рассматривать только печатные символы
  -M, --month-sort            сравнивать (неизвестно) < «JAN» < … < «DEC»
  -h, --human-numeric-sort    сравнивать числа в удобном для человека виде
                              (например, 2K 1G)
  -n, --numeric-sort          сравнивать по числовым значениям строк
  -R, --random-sort           перетасовать, но группировать одинаковые ключи.
                              Смотрите shuf(1)
      --random-source=ФАЙЛ    брать случайные байты из ФАЙЛА
  -r, --reverse               обратить результаты сравнения
      --sort=СЛОВО            сортировать согласно СЛОВУ:
                                general-numeric -g, human-numeric -h, month -M,
                                numeric -n, random -R, version -V
  -V, --version-sort          сортировать по номерам (версии) в текстовом
                              представлении

Другие ключи:

      --batch-size=NMERGE     объединять не более чем NMERGE ввода за раз;
                              для большего использовать временные файлы
  -c, --check, --check=diagnose-first
                               проверять, сортированы ли входные файлы;
                               не сортировать
  -C, --check=quiet, --check=silent
                               как -c, но не сообщать о первой плохой строке
      --compress-program=ПРОГ  сжимать временные файлы командой ПРОГ;
                               разжимать командой ПРОГ -d
      --debug                  комментировать часть строки, используемой для
                               сортировки и предупреждать о сомнительном
                               использовании в stderr
      --files0-from=Ф          читать ввод из файлов, имена которых
                                (завершённые нулем) перечислены в файле Ф.
                               Если Ф равно -, то читать имена файлов из
                               стандартного ввода
  -k, --key=ОПР_КЛЮЧА          сортировать по ключу; в ОПР_КЛЮЧА
                               задано расположение и тип
  -m, --merge                  объединить уже сортированные файлы,
                               не сортировать
  -o, --output=ФАЙЛ            выводить в ФАЙЛ, а не на стандартный вывод
  -s, --stable                 стабилизировать сортировку, исключив проверку
                               на равенство
  -S, --buffer-size=РАЗМЕР
                               использовать в основной памяти буфер указанного
                               РАЗМЕРА
  -t, --field-separator=РАЗДЕЛИТЕЛЬ
                               использовать при поиске ключевых полей
                               РАЗДЕЛИТЕЛЬ, а не переход от непробельных
                               символов к пробельным
  -T, --temporary-directory=КАТАЛОГ
                               использовать для временных файлов КАТАЛОГ, а
                               не $TMPDIR или /tmp; несколько таких ключей
                               задают несколько каталогов
      --parallel=N             изменить количество одновременно запущенных
                               сортировок до N
  -u, --unique                 с -c, проверять порядок строго;
                               без -c, выводить только первое среди нескольких
                               равных
  -z, --zero-terminated        разделитель строк NUL, а не символ
                               новой строки
      --help     показать эту справку и выйти
      --version  показать информацию о версии и выйти

	  
igor@igor-vm:~$ sort -nrk 2 hardware.txt
Processors:  500$ -- June 24 2016
Video: 485$ -- September 3  2017
M.B.:  125$ -- May 12 2017
USB: 15$ -- December 30 2017

-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-
tail — утилита в UNIX, выводящая несколько (по умолчанию 10) последних строк из файла.

Использование: tail [КЛЮЧ]… [ФАЙЛ]…
Печатает последние 10 строк каждого из ФАЙЛОВ на стандартный вывод.
Если задано несколько ФАЙЛОВ, сначала печатает заголовок с именем файла.

Если ФАЙЛ не задан или задан как -, читает стандартный ввод.

Аргументы, обязательные для длинных ключей, обязательны и для коротких.
  -c, --bytes=[+]Н         показать последние Н байт; или укажите -c +Н,
                           чтобы начать вывод каждого файла с Н-го байта
  -f, --follow[={name|descriptor}]
                           выводить поступающие данные по мере роста файла;
                           при отсутствии ключа используется «descriptor»
  -F                       эквивалент --follow=name --retry
  -n, --lines=Н            выводить последние Н строк, а не последние 10;
                           или используйте -n +Н для вывода, начиная с Н-ной
      --max-unchanged-stats=Н
                           c ключом --follow=name, повторно открывать ФАЙЛ,
                           который не изменялся последние Н (по умолчанию 5)
                           итераций, чтобы проверить, не был ли он удалён или
                           переименован (такое обычно бывает при ротации
                           файлов системных журналов); при использовании
                           механизма inotify этот параметр не требуется
      --pid=PID            с ключом -f, прерваться, когда процесс PID
                           завершает работу
  -q, --quiet, --silent    не выводить заголовки с именами файлов
      --retry              продолжать пытаться открыть файл даже когда он
                           недоступен
  -s, --sleep-interval=С   с ключом -f, спать между итерациями примерно
                           С секунд (по умолчанию 1.0); при использовании
                           механизма inotify и --pid=P, проверять процесс P
                           не менее чем раз в С секунд
  -v, --verbose            всегда выводить заголовки с именами файлов
  -z, --zero-terminated        разделитель строк NUL, а не символ
                               новой строки
      --help     показать эту справку и выйти
      --version  показать информацию о версии и выйти

-
# cat /home/captain/use_tail.txt

This is my unix/linux blog
I will write some examples
I will use tail with this file
Ok.
Let's start it!


-
# tail -n3 /home/captain/use_tail.txt

I will use tail with this file
Ok.
Let's start it!

-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-
tee — команда, выводит на экран, или же перенаправляет выходной материал команды и 
копирует его в файл или в переменную. В первую очередь, команда используется в привязке 
с перенаправлениями и фильтрами.

igor@igor-vm:~$ tee --help
Использование: tee [КЛЮЧ]… [ФАЙЛ]…
Копирует стандартный ввод в каждый ФАЙЛ, а также в стандартный вывод.

  -a, --append              дописать в заданные ФАЙЛЫ
  -i, --ignore-interrupts   игнорировать сигналы прерывания
  -p                          обнаруживать ошибки записи в не каналы
     --output-error[=РЕЖИМ]   поведение при ошибке. Описание РЕЖИМов далее
      --help     показать эту справку и выйти
      --version  показать информацию о версии и выйти

В РЕЖИМе задаётся поведение при ошибках записи в вывод:
  «warn»         диагностические ошибки записи в любой вывод
  «warn-nopipe»  диагностические ошибки записи в любой вывод кроме канала
  «exit»         завершать работу при ошибках записи в любой вывод
  «exit-nopipe»  завершать работу при ошибках записи в любой вывод кроме канала
По умолчанию значение РЕЖИМа для параметра -p равно «warn-nopipe».
Если --output-error не указан, то по умолчанию выполняет немедленное
прекращение работы при ошибке записи в канал, или диагностические
ошибки записи в любой не канальный вывод.

igor@igor-vm:~$ lint program.c | tee program.lint 
Эта команда покажет стандартные выходящие данные команды lint program.c на средстве вывода, 
в то же самое время она сохранит приобретенные данные в файл program.lint. 
Если таковой файл уже существует, он будет переписан.

-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-
Команда tr служит для перевода (замены) выбранных символов в другие символы или удаления их.

В отличие от большинства других программ командной строки, 
команда tr не принимает имен файлов в качестве аргумента. 
Ввод команды tr осуществляется или со стандартного ввода, 
или с вывода других программ путем перенаправления.

igor@igor-vm:~$ tr --help
Использование: tr [КЛЮЧ]… ТАБЛИЦА1 [ТАБЛИЦА2]
Преобразует, уплотняет и/или удаляет символы со стандартного ввода и
печатает на стандартный вывод.

  -c, -C, --complement    сначала получить дополнение ТАБЛИЦЫ1
  -d, --delete            удалять символы из ТАБЛИЦЫ1, не преобразовывать
  -s, --squeeze-repeats   замещать каждую последовательность повторяющихся
                          символов, перечисленных в последней указанной
                          ТАБЛИЦЕ на единственный такой символ
  -t, --truncate-set1     сначала сократить ТАБЛИЦУ1 до размера ТАБЛИЦЫ2
      --help     показать эту справку и выйти
      --version  показать информацию о версии и выйти

ТАБЛИЦы задаются как символьные строки. Во многих случаях символы представляют
сами себя. Воспринимаются следующие последовательности:

  \ННН            знак с восьмеричным кодом ННН (от 1 до 3 цифр)
  \\              обратная косая черта
  \a              звуковой сигнал
  \b              забой
  \f              перевод страницы
  \n              новая строка
  \r              возврат каретки
  \t              горизонтальная табуляция
  \v              вертикальная табуляция
  СИМ1-СИМ2        все символы от СИМ1 до СИМ2 в порядке возрастания
  [СИМ*]           СИМВОЛ заполняет ТАБЛИЦУ2 до длины ТАБЛИЦЫ1
  [СИМ*ЧИСЛО]      заданное ЧИСЛО одинаковых СИМВОЛОВ; ЧИСЛО восьмеричное,
                   если начинается с 0
  [:alnum:]        все буквы и цифры
  [:alpha:]        все буквы
  [:blank:]        все горизонтальные пробельные символы
  [:cntrl:]        все управляющие символы
  [:digit:]        все цифры
  [:graph:]        все печатные символы, исключая пробел
  [:lower:]        все строчные буквы
  [:print:]        все печатные символы, включая пробел
  [:punct:]        все знаки препинания
  [:space:]        все вертикальные или горизонтальные пробельные символы
  [:upper:]        все заглавные буквы
  [:xdigit:]       все шестнадцатеричные цифры
  [=СИМ=]          все символы, эквивалентные СИМВОЛУ

igor@igor-vm:~$ echo "my unix/linux blog linux-notes.org" | tr "[:lower:]" "[:upper:]"
MY UNIX/LINUX BLOG LINUX-NOTES.ORG

-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-
uniq — утилита Unix, с помощью которой можно вывести или отфильтровать повторяющиеся строки в файле. 
Если входной файл задан как («-») или не задан вовсе, чтение производится из стандартного ввода. 
Если выходной файл не задан, запись производится в стандартный вывод. Вторая и последующие копии
повторяющихся соседних строк не записываются. Повторяющиеся входные строки не распознаются, 
если они не следуют строго друг за другом, поэтому может потребоваться предварительная сортировка файлов.

igor@igor-vm:~$ uniq --help
Использование: uniq [КЛЮЧ]… [ВХОД [ВЫХОД]]
Фильтрует совпавшие строки из ВХОДА (или стандартного ввода),
записывая их в ВЫХОД (или стандартный вывод).

Без ключей совпавшие строки объединяются с первым появлением.

Аргументы, обязательные для длинных ключей, обязательны и для коротких.
  -c, --count           выводить число повторов в начале каждой строки
  -d, --repeated        выводить только повторяющиеся строки,
                        одну для каждой группы
  -D                      вывести все повторяющиеся строки
     --all-repeated[=МЕТОД]  подобно -D, но позволяет
                          разделять группы пустой строкой;
                          МЕТОД={none(default),prepend,separate}
  -f, --skip-fields=Н   не сравнивать первые Н полей
      --group[=МЕТОД]  показать все элементы, разделяя группы пустой строкой;
                          МЕТОД={separate(default),prepend,append,both}
  -i, --ignore-case     игнорировать регистр при сравнении
  -s, --skip-chars=Н    не сравнивать первые Н символов
  -u, --unique          выводить только неповторяющиеся строки
  -z, --zero-terminated        разделитель строк NUL, а не символ
                               новой строки
  -w, --check-chars=Н   сравнивать первые Н символов строк
      --help     показать эту справку и выйти
      --version  показать информацию о версии и выйти

 
Если в тексте следует подряд несколько одинаковых строк, то команда uniq уменьшит их количество до одной.
igor@igor-vm:~$ echo -e 1234\\n2345\\n3456\\n1111\\n1111\\n1111 | uniq
 1234
 2345
 3456
 1111
 
-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-
od — утилита в Unix системах для вывода дампа файла в восьмеричном формате. 
С разными параметрами, с помощью od можно увидеть содержимое файла в шестнадцатеричном, восьмеричном, 
десятичном и пр.(можно даже одновременно во всех форматах) виде с любого места любой длиной.

igor@igor-vm:~$ od --help
Использование: od [КЛЮЧ]… [ФАЙЛ]…
       или:    od [-abcdfilosx]… [ФАЙЛ] [[+]СМЕЩЕНИЕ[.][b]]
       или:    od --traditional [КЛЮЧ]… [ФАЙЛ] [[+]СМЕЩЕНИЕ[.][b] [+][МЕТКА][.][b]]

Печатает однозначное (по умолчанию байтовое восьмеричное) представление ФАЙЛА
на стандартный вывод.  Если указано несколько ФАЙЛОВ, то для формирования
ввода выполняется их объединение по порядку их указания.

Если ФАЙЛ не задан или задан как -, читает стандартный ввод.

Если применимы и первая, и вторая формы вызова, предполагается вторая
форма, если последний операнд начинается на + или (если заданы два
операнда) на цифру. Операнд СМЕЩЕНИЕ означает -j СМЕЩЕНИЕ. МЕТКА —
это псевдоадрес первого напечатанного байта; она увеличивается в процессе
вывода. Префикс 0x или 0X задает СМЕЩЕНИЕ или МЕТКУ как
шестнадцатеричные числа, суффикс . — как восьмеричные, а суффикс b
умножает на 512.

Аргументы, обязательные для длинных ключей, обязательны и для коротких.
  -A, --address-radix=ОСНОВАНИЕ  выходной формат для файловых смещений;
                                 ОСНОВАНИЕ может быть [doxn] — Decimal,
                                 Octal, Hex или None
      --endian={big|little}      переставлять местами входные байты согласно
                                 указанного порядку
  -j, --skip-bytes=Н             пропустить первые Н байт
  -N, --read-bytes=Н             считывать только Н байт
  -S Н, --strings[=Н]            выводить строки длиной, по меньшей мере, Н
                                 графических символов; если Н не задано,
                                 от используется значение 3
  -t, --format=ТИП               выбирает формат или форматы вывода
  -v, --output-duplicates        не помечать символом * невыводимые строки
  -w[Н], --width[=Н]             выводить Н байт в каждой выходной строке;
                                 если Н не задано, то используется Н=32
      --traditional              принимать аргументы как в третьей форме выше
      --help     показать эту справку и выйти
      --version  показать информацию о версии и выйти


Традиционные спецификации формата можно писать вперемешку, они объединяются:
  -a   синоним -t a,  именованные символы, старший бит игнорируется
  -b   синоним -t o1, восьмеричные байты
  -c   синоним -t c,  печатные символы или управляющие последовательности
       с обратной косой чертой
  -d   синоним -t u2, беззнаковые десятичные двухбайтовые единицы
  -f   синоним -t fF, числа с плавающей точкой
  -i   синоним -t dI, десятичные целые
  -l   синоним -t dL, десятичные длинные целые
  -o   синоним -t o2, восьмеричные двухбайтовые единицы
  -s   синоним -t d2, десятичные двухбайтовые единицы
  -x   синоним -t x2, шестнадцатеричные двухбайтовые единицы


ТИП составляется из одного или нескольких следующих спецификаций:
  a          именованный символ, старший бит игнорируется
  c          печатный символ или управляющая последовательность
  d[ЧИСЛО]   знаковое десятичное целое размером заданное ЧИСЛО байт
  f[ЧИСЛО]   число с плавающей точкой размером заданное ЧИСЛО байт
  o[ЧИСЛО]   восьмеричное целое размером заданное ЧИСЛО байт
  u[ЧИСЛО]   беззнаковое десятичное целое размером заданное ЧИСЛО байт
  x[ЧИСЛО]   шестнадцатеричное целое размером заданное ЧИСЛО байт

Если ФОРМАТ — одно из [doux], ЧИСЛО может задаваться как C sizeof(char),
S sizeof(short), I sizeof(int) или L sizeof(long). Если ФОРМАТ равен f, то
ЧИСЛО также может быть F sizeof(float), D sizeof(double) или
L sizeof(long double).

Добавляет суффикс z к любым показываемым печатным символам
в конце каждой выходной строки.


Н задаётся шестнадцатеричным числом с префиксом 0x или 0X, и может содержать
умножающий суффикс:
  b    512
  KB   1000
  K    1024
  MB   1000*1000
  M    1024*1024
и так далее для G, T, P, E, Z, Y.

igor@igor-vm:~$ od SlimRG.txt | head
 00000020 042577 043114 000401 000001 000000 000000 000000 000000
 0000020 000002 000003 000001 000000 101400 004004 000064 000000
 0000040 003610 000000 000000 000000 0000264 0200040 000006 000050
 0000060 000033 000030 000006 000000 000064 000000 100064 004004
 0000100 1000642 004004 000300 000000 000300 000000 000005 000000
 0000120 000004 000000 000003 000000 000364 000000 100364 004004
 0000140 100364 004004 000023 000000 000023 0000002 000004 000000
 0000160 000001 000000 0020001 000000 000000 000000 100000 004004
 0000200 100000 004004 002121 000000 002121 000000 000005 000000
 0000220 010000 000000 000001 000000 002124 000000 112124 004004
 
-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-
sum - программа получения суммы BSD checksum или  SYSV checksum
igor@igor-vm:~$ sum --help
Использование: sum [КЛЮЧ]… [ФАЙЛ]…                                                                                                             
Печатает контрольную сумму и количество блоков для каждого ФАЙЛА.                                                                              
                                                                                                                                               
Если ФАЙЛ не задан или задан как -, читает стандартный ввод.                                                                                   
                                                                                                                                               
  -r              использовать алгоритм вычисления контрольных сумм как в BSD,                                                                 
                  размер блока 1K                                                                                                              
  -s, --sysv      использовать алгоритм вычисления контрольных сумм как в                                                                      
                  System V, размер блока 512 байт                                                                                              
      --help     показать эту справку и выйти                                                                                                  
      --version  показать информацию о версии и выйти                                                                                          
                                                          
igor@igor-vm:~$ sum /bin/bash
35186  1074
-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-														  
Команда cut позволяет выбрать из каждой строки файла нужную часть 
(по единому правилу для всех строк) и показать выборку на экране дисплея.

Команда имеет три основные опции:

-b - когда объектом выбора являются байты;
-с - когда объектом выбора являются символы;
-f - когда объектом выбора являются элементы форматирования текста (колонки, столбцы и прочее).

igor@igor-vm:~$ cut --help
Использование: cut КЛЮЧ… [ФАЙЛ]…
Печатает выбранные части строк из каждого ФАЙЛА на стандартный вывод.

Если ФАЙЛ не задан или задан как -, читает стандартный ввод.

Аргументы, обязательные для длинных ключей, обязательны и для коротких.
  -b, --bytes=СПИСОК             выбрать только заданные байты
  -c, --characters=СПИСОК        выбрать только заданные символы
  -d, --delimiter=РАЗДЕЛИТЕЛЬ    использовать для разделения полей РАЗДЕЛИТЕЛЬ
                                 вместо табуляции
  -f, --fields=СПИСОК            выбрать только заданные поля; также печатать
                                 все строки, не содержащие разделителей, если
                                 только не задан ключ -s
  -n                             (игнорируется)
      --complement               дополнить множество выбранных байт, символов
                                 или полей
  -s, --only-delimited           не печатать строки, не содержащие
                                 разделителей
      --output-delimiter=СТРОКА  использовать СТРОКУ для разделения полей при
                                 выводе, по умолчанию используется разделитель
                                 для ввода
  -z, --zero-terminated        разделитель строк NUL, а не символ
                               новой строки
      --help     показать эту справку и выйти
      --version  показать информацию о версии и выйти

Используйте один и только один из ключей -b, -c или -f.  СПИСКИ
состоят из диапазона или нескольких диапазонов, разделенных запятыми.
Выбранные части входного файла печатаются в том порядке, в котором они
появляются на входе, и печатаются ровно один раз.
Диапазоны задаются следующим образом:

  Н     Н-ный байт, символ или поле; отсчитывается от 1
  Н-    от Н-ного байта, символа или поля до конца строки
  Н-М   от Н-ного до М-ного (включительно) байта, символа или поля
  -М    от первого до М-ного (включительно) байта, символа или поля

igor@igor-vm:~$ 
 /bin/sh
 /bin/sh
 /bin/h
 /bin/h
 /bin/h
 /bin/h
 
-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-	
nroff - эмуляция команды nroff с помощью groff, которая форматирует документы или
фиксирует длину для печати

Форматирует users.ls использую макросы из -me
igor@igor-vm:~$ nroff -s4 -me users.ls

igor@igor-vm:~$ nroff --help
usage: nroff [-CchipStUv] [-dCS] [-MDIR] [-mNAME] [-nNUM] [-oLIST]
             [-rCN] [-Tname] [-WNAME] [-wNAME] [FILE...]

	
-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-	
Vim (сокр. от Vi Improved, произносится «вим») — свободный текстовый редактор, 
созданный на основе более старого vi. Ныне это один из мощнейших текстовых редакторов 
с полной свободой настройки и автоматизации, возможными благодаря расширениям и надстройкам.
Пользовательский интерфейс Vim’а может работать в чистом текстовом (консольном) режиме.
 
По умолчанию в Kubuntu не установлен

vim --help
VIM - Vi IMproved 8.0 (2016 Sep 12, compiled Jul 26 2017 20:13:43)

Использование: vim [параметры] [файл ..] редактирование указанных файлов
   или: vim [параметры] -           чтение текста из потока ввода stdin
   или: vim [параметры] -t метка    редактирование файла с указанной меткой
   или: vim [параметры] -q [файл-ошибок]
                                    редактирование файла с первой ошибкой

Параметры:
   --                   Далее указываются только имена файлов
   -v                   Режим Vi (как "vi")
   -e                   Режим Ex (как "ex")
   -E                   Улучшенный режим Ex
   -s                   Тихий (пакетный) режим (только для "ex")
   -d                   Режим отличий (как "vimdiff")
   -y                   Простой режим (как "evim", безрежимный)
   -R                   Только для чтения (как "view")
   -Z                   Ограниченный режим (как "rvim")
   -m                   Без возможности сохранения изменений (записи файлов)
   -M                   Без возможности внесения изменений в текст
   -b                   Двоичный режим
   -l                   Режим Lisp
   -C                   Режим совместимости с Vi: 'compatible'
   -N                   Режим неполной совместимости с Vi: 'nocompatible'
   -V[N][файл]          Выводить дополнительные сообщения
                                [уровень N] [записывать в файл]
   -D                   Режим отладки
   -n                   Без своп-файла, используется только память
   -r                   Вывести список своп-файлов и завершить работу
   -r (с именем файла)  Восстановить аварийно завершённый сеанс
   -L                   То же, что и -r
   -A                   Запуск в Арабском режиме
   -H                   Запуск в режиме "Иврит"
   -F                   Запуск в режиме "Фарси"
   -T <терминал>        Назначить указанный тип <терминала>
   --not-a-term         Skip warning for input/output not being a terminal
   --ttyfail            Exit if input or output is not a terminal
   -u <vimrc>           Использовать <vimrc> вместо любых файлов .vimrc
   --noplugin           Не загружать сценарии модулей
   -p[N]                Открыть N вкладок (по умолчанию: по одной
                                на каждый файл)
   -o[N]                Открыть N окон (по умолчанию: по одному
                                на каждый файл)
   -O[N]                То же, что и -o, но с вертикальным разделением окон
   +                    Начать редактирование в конце файла
   +<lnum>              Начать редактирование в строке с номером <lnum>
   --cmd <команда>      Выполнить <команду> перед загрузкой файла vimrc
   -c <команда>         Выполнить <команду> после загрузки первого файла
   -S <сеанс>           Прочитать сценарий <сеанса> после загрузки
                                первого файла
   -s <сценарий>        Прочитать команды Обычного режима из
                                файла <сценария>
   -w <сценарий>        Добавлять все введённые команды в файл <сценария>
   -W <сценарий>        Записать все введённые команды в файл <сценария>
   -x                   Редактирование зашифрованных файлов
   --startuptime <файл> Записать временную метку о запуске в <файл>
   -i <viminfo>         Использовать вместо .viminfo файл <viminfo>
   -h или --help        Вывести справку (это сообщение) и завершить работу
   --version            Вывести информацию о версии Vim и завершить работу

vim textfile

-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-	
Midnight Commander — один из файловых менеджеров с текстовым интерфейсом типа
 Norton Commander для UNIX-подобных операционных систем,
 а также Microsoft Windows и Windows NT, OS/2, Mac OS X (но не Mac OS 9).
 
mcedit графический текстовый редактор
В отличии от nano не переносит строки

mcedit texty.txt

-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-	
tar — является одним из архиваторов, которые мы используем часто для создания бекапов. 
Часто не поддерживает сжатие (кроме надстроек GZip и Bzip2)

Очень много ключей

без сжатия
# tar -cvf my_mp3_collection.tar ./*.mp3
с сжатием
# tar czvf public_html.tar.gz /home/captain/public_html

-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-	
'gzip' сокращает размер заданных файлов используя кодирование
Зива -Лемеля (LZ77). Когда возможно, каждый файл замещается файлом с
расширением '.gz', при этом сохраняются владелец, режимы, доступ и
времена модификации (Другие расширения '-gz' для VMS, 'z' для MSDOS,
OS/2, FAT и Atari). Если никаких файлов не указано или имя файла '-',
то пакуется стандартный ввод и выдается на стандартный вывод. 'gzip'
пытается паковать только обычные файлы, в частности 'gzip' игнорирует
символические ссылки.

Ключи:

-c — выводить архив в стандартный вывод
-d — распаковать
-f — принудительно распаковывать или сжимать
-l — показать информацию об архиве
-r — рекурсивно перебирать каталоги
-0 — минимальный уровень сжатия
-9 — максимальный уровень сжатия

#gzip -c файл > архив.gz
-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-//-	


